using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Media;
using Avalonia.Platform;

namespace HyPrism.Controls
{
    /// <summary>
    /// A lightweight control that loads an SVG file, extracts simple shapes (Path, Circle, Rect, etc.),
    /// and renders them as a native PathIcon. This allows for full Opacity/Foreground animation support.
    /// </summary>
    public class SvgIcon : PathIcon
    {
        private static readonly Dictionary<string, Geometry> GeometryCache = new();

        public static readonly StyledProperty<string?> SourceProperty =
            AvaloniaProperty.Register<SvgIcon, string?>(nameof(Source));

        public string? Source
        {
            get => GetValue(SourceProperty);
            set => SetValue(SourceProperty, value);
        }

        protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
        {
            base.OnPropertyChanged(change);

            if (change.Property == SourceProperty)
            {
                LoadGeometry(change.GetNewValue<string?>());
            }
        }

        private void LoadGeometry(string? source)
        {
            if (string.IsNullOrWhiteSpace(source))
            {
                Data = null;
                return;
            }

            // Check cache first
            if (GeometryCache.TryGetValue(source, out var cachedGeometry))
            {
                Data = cachedGeometry;
                return;
            }

            try
            {
                // Normalize URI
                var uriString = source;
                if (uriString.StartsWith("/"))
                {
                    // Assuming the project name is HyPrism
                    uriString = $"avares://HyPrism{uriString}";
                }
                
                Console.WriteLine($"[SvgIcon] Loading: {source} -> {uriString}");
                var uri = new Uri(uriString, UriKind.Absolute);
                
                if (AssetLoader.Exists(uri))
                {
                    using var stream = AssetLoader.Open(uri);
                    var geometry = ParseSvgStream(stream);
                    
                    if (geometry != null)
                    {
                        Console.WriteLine($"[SvgIcon] Loaded geometry for {source}");
                        GeometryCache[source] = geometry;
                        Data = geometry;
                    }
                    else
                    {
                        Console.WriteLine($"[SvgIcon] Failed to parse geometry for {source}");
                    }
                }
                else
                {
                    Console.WriteLine($"[SvgIcon] Asset not found: {uriString}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[SvgIcon] Error loading {source}: {ex.Message}");
            }
        }

        private Geometry? ParseSvgStream(Stream stream)
        {
            try
            {
                var doc = XDocument.Load(stream);
                var root = doc.Root;
                if (root == null) return null;

                var group = new GeometryGroup();
                var ns = root.Name.Namespace;

                // Debug info
                Console.WriteLine($"[SvgIcon] Root NS: {ns}, Elements: {root.Elements().Count()}");

                // 1. <path d="..." />
                foreach (var pathNode in root.Descendants(ns + "path"))
                {
                    var d = pathNode.Attribute("d")?.Value;
                    if (!string.IsNullOrEmpty(d))
                    {
                        try 
                        {
                            // Fix: Ensure StreamGeometry is properly closed/instantiated?
                            // StreamGeometry.Parse returns a geometry that is ready to use.
                            var geo = StreamGeometry.Parse(d);
                            group.Children.Add(geo);
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"[SvgIcon] Failed to parse path: {ex.Message}");
                        }
                    }
                }

                // 2. <circle cx="..." cy="..." r="..." />
                foreach (var circleNode in root.Descendants(ns + "circle"))
                {
                    var cx = GetDouble(circleNode, "cx");
                    var cy = GetDouble(circleNode, "cy");
                    var r = GetDouble(circleNode, "r");
                    
                    group.Children.Add(new EllipseGeometry(new Rect(cx - r, cy - r, r * 2, r * 2)));
                }

                // 3. <rect x="..." y="..." width="..." height="..." rx="..." ry="..." />
                foreach (var rectNode in root.Descendants(ns + "rect"))
                {
                    var x = GetDouble(rectNode, "x");
                    var y = GetDouble(rectNode, "y");
                    var w = GetDouble(rectNode, "width");
                    var h = GetDouble(rectNode, "height");
                    var rx = GetDouble(rectNode, "rx");
                    var ry = GetDouble(rectNode, "ry");

                    // If ry is missing but rx exists, svg spec says ry = rx
                    if (rectNode.Attribute("ry") == null && rectNode.Attribute("rx") != null) ry = rx;
                    if (rectNode.Attribute("rx") == null && rectNode.Attribute("ry") != null) rx = ry;

                    group.Children.Add(new RectangleGeometry(new Rect(x, y, w, h), rx, ry));
                }

                // 4. <line x1="..." y1="..." x2="..." y2="..." />
                foreach (var lineNode in root.Descendants(ns + "line"))
                {
                    var x1 = GetDouble(lineNode, "x1");
                    var y1 = GetDouble(lineNode, "y1");
                    var x2 = GetDouble(lineNode, "x2");
                    var y2 = GetDouble(lineNode, "y2");

                    var lineGeo = new StreamGeometry();
                    using (var ctx = lineGeo.Open())
                    {
                        ctx.BeginFigure(new Point(x1, y1), false);
                        ctx.LineTo(new Point(x2, y2));
                    }
                    // For stroke to work on StreamGeometry, it needs to be opened/closed.
                    // But wait, line is just a line.
                    group.Children.Add(lineGeo);
                }
                
                // 5. <polyline points="..." /> and <polygon points="..." />
                foreach (var polyNode in root.Descendants().Where(n => n.Name.LocalName == "polyline" || n.Name.LocalName == "polygon"))
                {
                    var pointsStr = polyNode.Attribute("points")?.Value;
                    if (!string.IsNullOrEmpty(pointsStr))
                    {
                        var points = ParsePoints(pointsStr);
                        if (points.Count > 0)
                        {
                            var polyGeo = new StreamGeometry();
                            using (var ctx = polyGeo.Open())
                            {
                                ctx.BeginFigure(points[0], true); // IsFilled doesn't matter much for stroke
                                for (int i = 1; i < points.Count; i++)
                                {
                                    ctx.LineTo(points[i]);
                                }
                                if (polyNode.Name.LocalName == "polygon")
                                {
                                    ctx.EndFigure(true);
                                }
                            }
                            group.Children.Add(polyGeo);
                        }
                    }
                }

                if (group.Children.Count == 0)
                {
                    Console.WriteLine($"[SvgIcon] Warning: No supported shapes found in SVG.");
                }
                else 
                {
                     Console.WriteLine($"[SvgIcon] Parsed {group.Children.Count} shapes.");
                     // DEBUG: Add a visible box to ensure rendering works
                     // group.Children.Add(new RectangleGeometry(new Rect(0,0,24,24)));
                }

                return group;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[SvgIcon] XML Parse Error: {ex.Message}");
                return null;
            }
        }

        private double GetDouble(XElement element, string attributeName)
        {
            var val = element.Attribute(attributeName)?.Value;
            if (double.TryParse(val, NumberStyles.Any, CultureInfo.InvariantCulture, out var result))
            {
                return result;
            }
            return 0;
        }

        private List<Point> ParsePoints(string pointsStr)
        {
            var list = new List<Point>();
            // Split by comma or whitespace
            var parts = pointsStr.Split(new[] { ' ', ',', '\t', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
            
            for (int i = 0; i < parts.Length; i += 2)
            {
                if (i + 1 < parts.Length)
                {
                    if (double.TryParse(parts[i], NumberStyles.Any, CultureInfo.InvariantCulture, out var x) &&
                        double.TryParse(parts[i+1], NumberStyles.Any, CultureInfo.InvariantCulture, out var y))
                    {
                        list.Add(new Point(x, y));
                    }
                }
            }
            return list;
        }
    }
}
