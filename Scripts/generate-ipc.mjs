#!/usr/bin/env node
/**
 * generate-ipc.mjs — Auto-generates Frontend/src/lib/ipc.ts
 * This is the SINGLE source of truth for all IPC communication.
 *
 * Parses two kinds of annotations from Services/Core/IpcService.cs:
 *
 *   @type TypeName { field: type; field?: type; }
 *   @ipc invoke|send|event hyprism:domain:action -> ResponseType
 *
 * Produces a self-contained ipc.ts with:
 *   1. Window type augmentation (Electron bridge)
 *   2. Core helpers: send(), on(), invoke()
 *   3. All TypeScript interfaces (from @type)
 *   4. Typed domain API namespaces (from @ipc)
 *   5. Unified `ipc` export object
 *
 * Run: node Scripts/generate-ipc.mjs
 */

import { readFileSync, writeFileSync } from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const root = resolve(__dirname, '..');

const SOURCE = resolve(root, 'Services/Core/Ipc/IpcService.cs');
const OUTPUT = resolve(root, 'Frontend/src/lib/ipc.ts');

const source = readFileSync(SOURCE, 'utf-8');

// Parse @type annotations
// Format: /// @type TypeName { field: type; field?: type; }
const typeRe = /\/\/\/?\s*@type\s+(\w+)\s*\{([^}]+)\}/g;

/** @type {{ name: string, body: string }[]} */
const types = [];
let tm;
while ((tm = typeRe.exec(source)) !== null) {
  types.push({ name: tm[1], body: tm[2].trim() });
}

// Parse @ipc annotations (optional timeout: @ipc invoke channel -> Type 15000)
const ipcRe = /\/\/\s*@ipc\s+(invoke|send|event)\s+(hyprism:\S+)(?:\s*->\s*(.+?))?(?:\s+(\d+))?\s*$/gm;

/** @type {{ type: string, channel: string, responseType?: string, timeout?: number }[]} */
const channels = [];
let im;
while ((im = ipcRe.exec(source)) !== null) {
  channels.push({
    type: im[1],
    channel: im[2],
    responseType: im[3]?.trim() || undefined,
    timeout: im[4] ? parseInt(im[4], 10) : undefined,
  });
}

// Group by domain
/** @type {Record<string, typeof channels>} */
const domains = {};
for (const ch of channels) {
  const domain = ch.channel.split(':')[1];
  if (!domains[domain]) domains[domain] = [];
  domains[domain].push(ch);
}

// Emit TypeScript
const L = [];

L.push(`/*`);
L.push(` .-..-.      .---.       _                  `);
L.push(` : :; :      : .; :     :_;                 `);
L.push(` :    :.-..-.:  _.'.--. .-. .--. ,-.,-.,-.  `);
L.push(` : :: :: :; :: :   : ..': :\`._-.': ,. ,. : `);
L.push(` :_;:_;\`._. ;:_;   :_;  :_;\`.__.':_;:_;:_;`);
L.push(`        .-. :                               `);
L.push(`        \`._.'            generated IPC API `);
L.push(``);
L.push(`AUTO-GENERATED BY generate-ipc.mjs — DO NOT EDIT MANUALLY!`);
L.push(`SOURCE: Services/Core/IpcService.cs (@type + @ipc annotations)`);
L.push(`*/`);
L.push(``);

// 1. Electron require + ipcRenderer
L.push(`// eslint-disable-next-line @typescript-eslint/no-require-imports`);
L.push(`const { ipcRenderer } = (window as any).require('electron');`);
L.push(``);

// 2. Core helpers
L.push(`// #region Core IPC helpers`);
L.push(``);
L.push(`export function send(channel: string, data?: unknown): void {`);
L.push(`  ipcRenderer.send(channel, data != null ? JSON.stringify(data) : undefined);`);
L.push(`}`);
L.push(``);
L.push(`export function on(channel: string, callback: (data: unknown) => void): () => void {`);
L.push(`  const listener = (_event: unknown, ...args: unknown[]) => {`);
L.push(`    const raw = args.length === 1 ? args[0] : args;`);
L.push(`    // Backend sends JSON.Serialize(data), so we need to parse it`);
L.push(`    let parsed = raw;`);
L.push(`    if (typeof raw === 'string') {`);
L.push(`      try { parsed = JSON.parse(raw); } catch { /* keep raw */ }`);
L.push(`    }`);
L.push(`    callback(parsed);`);
L.push(`  };`);
L.push(`  ipcRenderer.on(channel, listener);`);
L.push(`  return () => { ipcRenderer.removeListener(channel, listener); };`);
L.push(`}`);
L.push(``);
L.push(`export function invoke<T = unknown>(channel: string, data?: unknown, timeout = 10000): Promise<T> {`);
L.push(`  return new Promise((resolve, reject) => {`);
L.push('    const replyChannel = `${channel}:reply`;');
L.push(`    const timer = setTimeout(() => {`);
L.push(`      cleanup();`);
L.push('      reject(new Error(`IPC timeout on ${channel}`));');
L.push(`    }, timeout);`);
L.push(``);
L.push(`    const cleanup = on(replyChannel, (response) => {`);
L.push(`      clearTimeout(timer);`);
L.push(`      cleanup();`);
L.push(`      try {`);
L.push(`        const parsed = typeof response === 'string' ? JSON.parse(response) : response;`);
L.push(`        resolve(parsed as T);`);
L.push(`      } catch {`);
L.push(`        resolve(response as T);`);
L.push(`      }`);
L.push(`    });`);
L.push(``);
L.push(`    send(channel, data);`);
L.push(`  });`);
L.push(`}`);
L.push(``);
L.push(`// #endregion`);
L.push(``);

// 3. Interfaces from @type
L.push(`// #region Types (from @type annotations)`);
L.push(``);
for (const t of types) {
  // Convert "field: type; field?: type;" to multi-line interface
  const fields = t.body
    .split(';')
    .map(f => f.trim())
    .filter(Boolean);

  L.push(`export interface ${t.name} {`);
  for (const field of fields) {
    L.push(`  ${field};`);
  }
  L.push(`}`);
  L.push(``);
}

L.push(`// #endregion`);
L.push(``);

// 4. Domain API namespaces
L.push(`// #region Typed IPC API (from @ipc annotations)`);
L.push(``);

const domainNames = [];
for (const [domain, chs] of Object.entries(domains)) {
  // Avoid collision with global `window` and `console`
  const exportName = domain === 'window' ? 'windowCtl' : domain === 'console' ? 'consoleCtl' : domain;
  domainNames.push({ domain, exportName });

  L.push(`const _${domain} = {`);

  for (const ch of chs) {
    const action = ch.channel.split(':').slice(2).join('_');
    const resp = ch.responseType || 'void';

    if (ch.type === 'invoke') {
      const noData = ['get', 'current', 'list', 'instances', 'languages', 'gpuAdapters'].includes(action);
      const timeoutArg = ch.timeout ? `, ${ch.timeout}` : '';
      if (noData) {
        const undefinedData = ch.timeout ? ', undefined' : '';
        L.push(`  ${action}: () => invoke<${resp}>('${ch.channel}'${undefinedData}${timeoutArg}),`);
      } else {
        L.push(`  ${action}: (data?: unknown) => invoke<${resp}>('${ch.channel}', data${timeoutArg}),`);
      }
    } else if (ch.type === 'send') {
      if (action === 'open') {
        L.push(`  ${action}: (data: string) => send('${ch.channel}', data),`);
      } else if (['log', 'warn', 'error'].includes(action)) {
        L.push(`  ${action}: (msg: string) => send('${ch.channel}', msg),`);
      } else {
        L.push(`  ${action}: (data?: unknown) => send('${ch.channel}', data),`);
      }
    } else if (ch.type === 'event') {
      const cap = action.charAt(0).toUpperCase() + action.slice(1);
      L.push(`  on${cap}: (cb: (data: ${resp}) => void) => on('${ch.channel}', cb as (d: unknown) => void),`);
    }
  }

  L.push(`};`);
  L.push(``);
}

L.push(`// #endregion`);
L.push(``);

// 5. Unified `ipc` export
L.push(`// #region Unified export`);
L.push(``);
L.push(`export const ipc = {`);
for (const { domain, exportName } of domainNames) {
  L.push(`  ${exportName}: _${domain},`);
}
L.push(`};`);
L.push(``);
L.push(`// #endregion`);
L.push(``);

const output = L.join('\n');
writeFileSync(OUTPUT, output, 'utf-8');

console.log(`✓ Generated ${OUTPUT}`);
console.log(`  ${types.length} types, ${channels.length} channels, ${Object.keys(domains).length} domains`);
